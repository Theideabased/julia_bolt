import { BaseProvider } from '../base-provider';
import { JuliaOSBridge } from '../../juliaos/bridge';
import type { ModelInfo } from '../types';
import type { LanguageModelV1 } from 'ai';
import type { IProviderSetting } from '~/types/model';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('JuliaAgentProvider');

export default class JuliaAgentProvider extends BaseProvider {
  name = 'JuliaOS';
  getApiKeyLink = 'https://github.com/settings/tokens';
  labelForGetApiKey = 'Get GitHub Token';
  
  config = {
    apiTokenKey: 'GITHUB_TOKEN',
  };

  staticModels: ModelInfo[] = [
    {
      name: 'julia-agent-dev',
      label: 'Julia Agent (Development)',
      provider: this.name,
      maxTokenAllowed: 8192,
    },
    {
      name: 'julia-agent-research',
      label: 'Julia Agent (Research)',
      provider: this.name,
      maxTokenAllowed: 8192,
    },
    {
      name: 'julia-agent-testing',
      label: 'Julia Agent (Testing)',
      provider: this.name,
      maxTokenAllowed: 8192,
    },
    {
      name: 'julia-agent-deployment',
      label: 'Julia Agent (Deployment)',
      provider: this.name,
      maxTokenAllowed: 8192,
    },
  ];
  
  private bridge: JuliaOSBridge;
  private agentCache: Map<string, string> = new Map();

  constructor() {
    super();
    this.bridge = new JuliaOSBridge();
  }

  getModelInstance(options: {
    model: string;
    serverEnv?: Env;
    apiKeys?: Record<string, string>;
    providerSettings?: Record<string, IProviderSetting>;
  }): LanguageModelV1 {
    const { model, serverEnv, apiKeys } = options;
    
    // Get GitHub token for enhanced capabilities
    const { apiKey: githubToken } = this.getProviderBaseUrlAndKey({
      apiKeys,
      providerSettings: options.providerSettings?.[this.name],
      serverEnv: serverEnv as any,
      defaultBaseUrlKey: '',
      defaultApiTokenKey: 'GITHUB_TOKEN',
    });
    
    if (!githubToken) {
      logger.warn('GitHub token not found - Julia agent capabilities will be limited');
    }

    return {
      specificationVersion: 'v1',
      provider: this.name,
      modelId: model,
      defaultObjectGenerationMode: 'tool',
      
      doGenerate: async (options) => {
        try {
          // Initialize bridge if not already done
          if (!this.bridge.isConnected()) {
            await this.bridge.initialize();
          }

          // Create or get agent for this model type
          const agentType = this.getAgentTypeFromModel(model);
          let agentId = this.agentCache.get(model);
          
          if (!agentId) {
            const agent = await this.bridge.runJuliaCommand('agents.create_agent', {
              name: `JuliaAgent_${agentType}`,
              type: agentType,
              config: {
                llmProvider: 'juliaos',
                model: model,
                githubToken: githubToken,
                maxTokens: 8192,
                temperature: 0.7,
                capabilities: [
                  'code_generation',
                  'code_analysis', 
                  'debugging',
                  'testing',
                  'deployment',
                  'github_integration',
                  'project_management'
                ]
              }
            });
            agentId = agent.id;
            if (agentId) {
              this.agentCache.set(model, agentId);
            }
            
            console.log(`ðŸ† JULIAOS: Created ${agentType} agent for no-code development`);
            console.log(`ðŸ”§ JULIAOS AGENT: ${agent.name} ready to power the application`);
          }

          if (!agentId) {
            throw new Error('Failed to create or retrieve Julia agent');
          }

          // Extract messages from the prompt
          const messages = Array.isArray(options.prompt) ? options.prompt : [options.prompt];
          const systemMessage = messages.find(m => m.role === 'system');
          const userMessages = messages.filter(m => m.role === 'user');
          
          const systemPrompt = systemMessage?.content || '';
          const combinedPrompt = `${systemPrompt}\n\n${userMessages.map(m => 
            typeof m.content === 'string' ? m.content : JSON.stringify(m.content)
          ).join('\n')}`;

          // Use Julia agent for LLM processing
          const response = await this.bridge.useLLM(agentId, combinedPrompt, {
            model: model,
            maxTokens: options.maxTokens || 8192,
            temperature: options.temperature || 0.7,
            githubIntegration: !!githubToken,
            noCodeDevelopment: true,
            competitionMode: true
          });

          console.log(`ðŸ† JULIAOS RESPONSE: Generated by ${model} agent`);
          console.log(`âš¡ï¸ JULIAOS FRAMEWORK: Powering no-code development`);

          // Format response according to AI SDK v1 specification
          return {
            text: response.result,
            finishReason: 'stop' as const,
            usage: {
              promptTokens: response.tokens?.prompt || 0,
              completionTokens: response.tokens?.completion || 0,
            },
            rawCall: {
              rawPrompt: combinedPrompt,
              rawSettings: {
                model: model,
                agentId: agentId,
                juliaosFramework: true
              }
            },
            rawResponse: {
              headers: {},
              body: JSON.stringify(response)
            },
            warnings: githubToken ? undefined : [{ 
              type: 'other' as const,
              message: 'GitHub token not provided - some features may be limited'
            }],
          };
          
        } catch (error: any) {
          logger.error('Julia agent generation failed:', error);
          throw new Error(`Julia agent error: ${error.message}`);
        }
      },

      doStream: async (options) => {
        // Call doGenerate from this same instance to get the result
        const doGenerateFunc = this.getModelInstance({
          model,
          serverEnv,
          apiKeys,
          providerSettings: undefined
        }).doGenerate;
        
        const generateResult = await doGenerateFunc(options);
        
        return {
          stream: new ReadableStream({
            start(controller) {
              // Simulate streaming by chunking the response
              const text = generateResult.text || '';
              const chunks = text.split(' ');
              
              chunks.forEach((chunk: string, index: number) => {
                setTimeout(() => {
                  controller.enqueue({
                    type: 'text-delta' as const,
                    textDelta: chunk + (index < chunks.length - 1 ? ' ' : ''),
                  });
                  
                  if (index === chunks.length - 1) {
                    controller.enqueue({
                      type: 'finish' as const,
                      finishReason: 'stop' as const,
                      usage: generateResult.usage,
                      logprobs: undefined
                    });
                    controller.close();
                  }
                }, index * 50); // 50ms delay between chunks
              });
            }
          }),
          rawCall: generateResult.rawCall,
          rawResponse: generateResult.rawResponse,
          warnings: generateResult.warnings
        };
      }
    };
  }

  private getAgentTypeFromModel(model: string): 'dev' | 'research' | 'testing' | 'deployment' | 'monitoring' {
    if (model.includes('research')) return 'research';
    if (model.includes('testing')) return 'testing';
    if (model.includes('deployment')) return 'deployment';
    if (model.includes('monitoring')) return 'monitoring';
    return 'dev'; // default
  }
}
